// Fixed MistralApiClient.java with proper timeout handling
package com.datalingo.one.service;

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.reactive.function.BodyInserters;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.datalingo.one.config.MistralConfig;
import com.fasterxml.jackson.databind.JsonNode;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;
import reactor.netty.resources.ConnectionProvider;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;

import java.time.Duration;
import java.util.Map;
import java.util.HashMap;

@Service
@Slf4j
public class MistralApiClient {

    private final WebClient webClient;
    private final MistralConfig config;
    private final ObjectMapper objectMapper;

    public MistralApiClient(MistralConfig config, ObjectMapper objectMapper) {
        this.config = config;
        this.objectMapper = objectMapper;
        
        // Create custom HTTP client with longer timeouts
        ConnectionProvider connectionProvider = ConnectionProvider.builder("ollama-pool")
            .maxConnections(10)
            .maxIdleTime(Duration.ofMinutes(2))
            .maxLifeTime(Duration.ofMinutes(5))
            .pendingAcquireTimeout(Duration.ofSeconds(60))
            .build();
        
        HttpClient httpClient = HttpClient.create(connectionProvider)
            .responseTimeout(Duration.ofMinutes(3))  // 3 minute response timeout
            .keepAlive(true);
        
        this.webClient = WebClient.builder()
            .baseUrl(config.getBaseUrl())
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(10 * 1024 * 1024))
            .build();
        
        log.info("MistralApiClient initialized with model: {}, timeout: {}s", 
                config.getModelName(), config.getTimeoutSeconds());
    }

    /**
     * Send query to local Mistral model via Ollama API with proper timeout handling
     */
    public Mono<String> generateQuery(String prompt) {
        Map<String, Object> requestBody = createRequestBody(prompt);
        
        log.info("Sending request to Ollama - model: {}, promptLength: {}, timeout: {}s", 
                config.getModelName(), prompt.length(), config.getTimeoutSeconds());

        return webClient.post()
            .uri("/api/generate")
            .header("Content-Type", "application/json")
            .body(BodyInserters.fromValue(requestBody))
            .retrieve()
            .bodyToMono(String.class)
            .timeout(Duration.ofSeconds(config.getTimeoutSeconds()))  // This should be longer than Spring's timeout
            .map(this::extractResponse)
            .doOnSuccess(response -> log.info("Successfully received response from Ollama"))
            .doOnError(error -> logDetailedError(error))
            .onErrorResume(error -> handleError(error));
    }
    
    private Map<String, Object> createRequestBody(String prompt) {
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("model", config.getModelName());
        requestBody.put("prompt", prompt);
        requestBody.put("stream", false);
        
        // Optimized options for faster response
        Map<String, Object> options = new HashMap<>();
        options.put("temperature", 0.1);
        options.put("top_p", 0.9);
        options.put("num_predict", 300);  // Reduced for faster response
        options.put("num_ctx", 2048);     // Context window
        options.put("repeat_penalty", 1.1);
        options.put("stop", new String[]{"```", "---", "END"});
        
        requestBody.put("options", options);
        return requestBody;
    }

    private void logDetailedError(Throwable error) {
        if (error instanceof WebClientResponseException) {
            WebClientResponseException webError = (WebClientResponseException) error;
            log.error("Ollama API error - Status: {}, Body: {}, Headers: {}", 
                     webError.getStatusCode(), 
                     webError.getResponseBodyAsString(),
                     webError.getHeaders());
        } else {
            log.error("Ollama request failed: {}", error.getMessage(), error);
        }
    }

    private Mono<String> handleError(Throwable error) {
        String errorMessage;
        
        if (error instanceof java.util.concurrent.TimeoutException || 
            error.getMessage().contains("timeout")) {
            errorMessage = "Request timed out - Ollama model may be slow to respond";
            log.warn("Timeout occurred - consider increasing timeout or using a smaller model");
        } else if (error instanceof WebClientResponseException) {
            WebClientResponseException webError = (WebClientResponseException) error;
            errorMessage = String.format("HTTP %s: %s", 
                                        webError.getStatusCode(), 
                                        webError.getResponseBodyAsString());
        } else {
            errorMessage = error.getMessage();
        }
        
        return Mono.just("ERROR: Failed to generate query - " + errorMessage);
    }

    private String extractResponse(String jsonResponse) {
        try {
            JsonNode responseNode = objectMapper.readTree(jsonResponse);
            
            if (responseNode.has("error")) {
                String error = responseNode.get("error").asText();
                log.error("Ollama returned error: {}", error);
                return "ERROR: " + error;
            }
            
            if (responseNode.has("response")) {
                String response = responseNode.get("response").asText();
                log.debug("Raw Ollama response: {}", response);
                return cleanResponse(response);
            } else {
                log.error("No 'response' field in Ollama response: {}", responseNode);
                return "ERROR: Invalid response format from Ollama";
            }
            
        } catch (Exception e) {
            log.error("Error parsing Ollama response: {}", e.getMessage(), e);
            return "ERROR: Failed to parse response - " + e.getMessage();
        }
    }
    
    private String cleanResponse(String response) {
        if (response == null || response.trim().isEmpty()) {
            return "ERROR: Empty response from model";
        }
        
        // Clean the response
        String cleaned = response
            .replaceAll("(?i)^(SQL Query:|Query:|```sql|```)", "")
            .replaceAll("(?i)(```|```)$", "")
            .replaceAll("\\*\\*", "")  // Remove bold markdown
            .trim();
        
        // If response contains explanation, try to extract just the SQL
        if (cleaned.contains("\n")) {
            String[] lines = cleaned.split("\n");
            for (String line : lines) {
                line = line.trim();
                if (line.toUpperCase().startsWith("SELECT") || 
                    line.toUpperCase().startsWith("INSERT") ||
                    line.toUpperCase().startsWith("UPDATE") ||
                    line.toUpperCase().startsWith("DELETE")) {
                    return line;
                }
            }
        }
        
        return cleaned;
    }

    public Mono<Boolean> checkHealth() {
        return webClient.get()
            .uri("/api/tags")
            .retrieve()
            .bodyToMono(String.class)
            .timeout(Duration.ofSeconds(10))
            .map(response -> response.contains(config.getModelName()))
            .onErrorReturn(false);
    }
}