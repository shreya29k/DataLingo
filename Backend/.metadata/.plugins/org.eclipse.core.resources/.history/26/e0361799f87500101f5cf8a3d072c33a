package com.datalingo.one.client;

import com.datalingo.one.dto.QueryRequest;
import com.datalingo.one.dto.QueryResponse;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;

import java.util.HashMap;
import java.util.Map;

@Component
public class QueryProcessingServiceClient {
    
    private static final Logger log = LoggerFactory.getLogger(QueryProcessingServiceClient.class);
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    @Value("${app.services.query-processing.base-url:http://localhost:8081}")
    private String queryProcessingBaseUrl;
    
    @Value("${app.services.query-processing.timeout:60000}")
    private int timeoutMs;
    
    public QueryProcessingServiceClient(RestTemplate restTemplate, ObjectMapper objectMapper) {
        this.restTemplate = restTemplate;
        this.objectMapper = objectMapper;
    }
    
    /**
     * Call the QueryProcessingService microservice to generate SQL
     */
    public QueryResponse processQuery(String naturalLanguageQuery, String databaseType) {
        try {
            log.info("Calling QueryProcessingService for query: {}", naturalLanguageQuery);
            
            // Prepare request
            QueryRequest request = new QueryRequest();
            request.setNaturalLanguageQuery(naturalLanguageQuery);
            request.setDatabaseType(databaseType);
            
            // Set headers
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.add("User-Agent", "DataSourceService/1.0");
            
            HttpEntity<QueryRequest> entity = new HttpEntity<>(request, headers);
            
            // Make the call
            String url = queryProcessingBaseUrl + "/api/query/process";
            ResponseEntity<QueryResponse> response = restTemplate.exchange(
                url,
                HttpMethod.POST,
                entity,
                QueryResponse.class
            );
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                log.info("Successfully received query from QueryProcessingService");
                return response.getBody();
            } else {
                log.error("Unexpected response from QueryProcessingService: {}", response.getStatusCode());
                return createErrorResponse("Unexpected response from query processing service");
            }
            
        } catch (HttpClientErrorException e) {
            log.error("Client error calling QueryProcessingService: {} - {}", e.getStatusCode(), e.getResponseBodyAsString());
            return createErrorResponse("Query processing failed: " + e.getMessage());
        } catch (HttpServerErrorException e) {
            log.error("Server error in QueryProcessingService: {} - {}", e.getStatusCode(), e.getResponseBodyAsString());
            return createErrorResponse("Query processing service error: " + e.getMessage());
        } catch (Exception e) {
            log.error("Error calling QueryProcessingService: {}", e.getMessage(), e);
            return createErrorResponse("Failed to connect to query processing service: " + e.getMessage());
        }
    }
    
    /**
     * Test connection to QueryProcessingService
     */
    public boolean testConnection() {
        try {
            String url = queryProcessingBaseUrl + "/actuator/health";
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            log.warn("QueryProcessingService health check failed: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Get available models from QueryProcessingService
     */
    public Map<String, Object> getAvailableModels() {
        try {
            String url = queryProcessingBaseUrl + "/api/query/models";
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                return response.getBody();
            }
        } catch (Exception e) {
            log.warn("Failed to get available models: {}", e.getMessage());
        }
        
        return Map.of("error", "Unable to retrieve available models");
    }
    
    private QueryResponse createErrorResponse(String errorMessage) {
        QueryResponse errorResponse = new QueryResponse();
        errorResponse.setExecutable(false);
        errorResponse.setGeneratedQuery(null);
        errorResponse.setWarnings(java.util.Arrays.asList(errorMessage));
        return errorResponse;
    }
}